syntax = "proto3";

package deathnode.sync;

option java_package = "com.deathnode.common.grpc";
option java_outer_classname = "SyncProto";
option java_multiple_files = true;

// ============================================================================
// Client -> Server Messages
// ============================================================================

/**
 * Initial handshake message from client.
 */
message Hello {
  string node_id = 1;
  bool start_sync = 2;  // true if this node wants to initiate a sync round
}

/**
 * Client uploads its buffered envelopes to the server.
 */
message BufferUpload {
  string node_id = 1;
  
  // Each envelope is the complete JSON bytes of the envelope
  repeated bytes envelopes = 2;
  
  // Placeholder for future: signed Merkle root of the buffer
  bytes signed_buffer_root = 3;
  
  // Last known state (for chain verification placeholder)
  int64 last_node_sequence = 4;
  string last_envelope_hash = 5;  // hex string
}

/**
 * Client message union.
 */
message ClientMessage {
  oneof body {
    Hello hello = 1;
    BufferUpload buffer_upload = 2;
  }
}

// ============================================================================
// Server -> Client Messages
// ============================================================================

/**
 * Server requests buffer from client for a sync round.
 */
message RequestBuffer {
  string round_id = 1;
  string message = 2;  // Human-readable instruction
}

/**
 * Server returns the globally ordered envelopes.
 */
message SyncResult {
  string round_id = 1;
  
  // All envelopes from all nodes, globally ordered
  repeated bytes ordered_envelopes = 2;
  
  // Corresponding hashes (same order)
  repeated string envelope_hashes = 3;
  
  // Placeholder for future: server-signed block commitment
  bytes signed_block_root = 4;
  
  // Placeholder for future: per-node signed buffer roots
  repeated SignedBufferRoot per_node_roots = 5;
  
  // Reference to previous block (for chaining)
  string prev_block_root = 6;
}

/**
 * Placeholder for future: represents a node's signed buffer commitment.
 */
message SignedBufferRoot {
  string node_id = 1;
  bytes merkle_root = 2;
  bytes signature = 3;
}

/**
 * Simple acknowledgment message.
 */
message Ack {
  bool success = 1;
  string message = 2;
}

/**
 * Error message.
 */
message Error {
  string code = 1;
  string message = 2;
  repeated string details = 3;
}

/**
 * Server message union.
 */
message ServerMessage {
  oneof body {
    RequestBuffer request_buffer = 1;
    SyncResult sync_result = 2;
    Ack ack = 3;
    Error error = 4;
  }
}

// ============================================================================
// Service Definition
// ============================================================================

/**
 * Bidirectional streaming RPC for synchronization.
 * 
 * Flow:
 * 1. Client sends Hello
 * 2. Server responds with RequestBuffer
 * 3. Client sends BufferUpload
 * 4. Server collects from all nodes, orders, and sends SyncResult
 * 5. Stream closes
 */
service SyncService {
  rpc Sync(stream ClientMessage) returns (stream ServerMessage);
}